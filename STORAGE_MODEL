This is an evolving document containing a snapshot of the current
suggested/draft storage model. Background/random ramblings that
informed it are in THOUGHTS.

Assume the underlying storage model is that of an S3 bucket or roughly
similar (eventually consistent or otherwise durable).

== Encryption ==

Unless encryption is disabled, all operations require a "secret". A
"secret" is generated by shastity upon the user's request, and comes
in the form of a file containing ASCII characters (a clojure map,
probably).

This secret contains:

  * An cryptographic key.
  * A random sequence of bytes used to initialize the hash function for the purpose
    of content addressalbe storage. This sequence of bytes is completely unrelated
    to the cryptographic key.

== File contents ==

Each file is dividied into a number of blocks, of a certain size. The
size shall be small enough that the data can be treated as a value on
the heap (no streaming support necessary anywhere), and large enough
to yield a reasonable number of files (for cost or speed-of-access
reasons if seek bound).

The size can be arbitrarily chosen at the point of backup; the only
penalty for "changing" it is that de-duplication is defeated if the
same file is backed up multiple times with different block sizes.

Each chunk is identified by the hash of its contents.

The contents of a file can thus be represented as a sequence of hashes:

  myfile = [ hex1 hex2 hex3 hex4 ]

Each hash corresponds to a file by that name stored in a bucket,
yielding implicit de-duplication due to the content addressable nature
of the storage.

In order to re-construct the file, one obtains the files 'hex1',
'hex2', 'hex3' and 'hex4' from the storage bucket, and writes them (in
order) to a file which, when done, represents the recovered file.

=== Encryption ===

When encryption is enabled, each hash is not the hash of the chunk,
but instead the hash of the secret byte sequence concatenated with the
contents of the chunk.

We cannot use any IV here becaues the entire point is for the filename
to be deterministic on contents.

Additionally, the actual contents of each chunk is encrypted using the
cryptographic key stored in the secret and (TODO) potentially HMAC:ed.

== File meta data and directory structure ==

The file listing can be thought of as a tree (with variable branching
factor) that directly corresponds to the directory structure being
backed up; in other words, each directoy is a node in the tree, and
each subdirectory or file is referenced by that node as a child.

Each node is stored in a content addressable fashion under its own
hash in a separate bucket from file contents (to allow separate
iteration for garbage collection).

Nodes refer to other nodes by their hash.

(The structure is very similar to that of a tree in git.)

This structure allows for natural de-duplication of the meta data
itself utilizing the natural structure already there in the file
system.

It also allows us to treat each node as a value; there is no need to
stream through an ordered (by path) sequence of entries under the
assumption that it cannot be kept in memory.

(To support truly huge directories, or add additional de-duplication
efficiency for semi-large directories, we would split a single
directory into a tree, but we will not have to support this in the
initial version.)

=== Encryption ===

Similarly to file contents, when encryption is enabled we substitute
all hashes with the hashes of the secret sequence of bytes
concatenated with the contents otherwise hashed.

In addition, the contents of each blob is encrypted (TODO, and
HMAC:ed?) using the cryptographic key.

== Backup manifest ==

Each logical backup (the result of running shastity on a directory
structure) is represented by a manifest. A manifest is a file
containing various meta-data (probably a clojure map). Probably date,
hostname of backup, user-provided information, etc. But critically, it
contains a pointer (by hash) to the root directory entry as described
in the preceding section.

The manifest is stored under a name which is a UUID, generated for
uniqueness.

=== Encryption ===

When encryption is enabled, each manifest is encrypted (TODO and
HMAC:ed?) using the cryptographic key in the secret.

== Security ==

Crypto people should probably evaluate the safety of hashing the same
secret bytes with contents to generate the file names of content
addressible data. We cannot use an IV since that would defeat the
content addressible property.

However, since we use a sequence of bytes that is completely unrelated
to the cryptographic key, any attack on this part of the storage model
should at least be limited to leaking the fact that a known piece of
data was backed up, and would not get anyone closer to decrypting any
data.

